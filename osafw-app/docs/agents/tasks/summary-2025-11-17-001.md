## What changed
- Simplified DB timezone resolution to resolve/cache the timezone ID inside the getter, defaulting to autodetect when config is empty and falling back to UTC if system lookup fails.
- Adjusted SQL Server timezone autodetect to use the current offset and map it to a system timezone, keeping conversions accurate without relying on server-specific names.
- Added inline guidance to `FwModel.convertUserInput` about how datetime branches normalize values to UTC while leaving NOW markers intact.
- ParsePage continues to assume UTC input while user-facing formatting happens via `FW.formatUserDateTime` and related helpers.

## Commands that worked (build/test/run)
- (none – dotnet CLI missing in container)

## Pitfalls - fixes
- `dotnet test` is unavailable because the container lacks the `dotnet` executable, so no automated build/test validation could run.

## Decisions - why
- Per-DB timezone resolution plus UTC normalization in `DB` keeps storage consistent while respecting connection-specific settings.
- Centralizing display conversion in `FW.formatUserDateTime` ensures UI paths use the user’s timezone regardless of which DB supplied the data.
- Moving user-input datetime conversion into `convertUserInput` keeps controllers thin while guaranteeing UTC normalization ahead of DB writes.
- ParsePage remains predictable by assuming UTC input and only handling output conversion for the user.

## Heuristics (keep terse)
- Run list/detail rows through `fw.formatUserDateTime` before returning JSON if ParsePage templating is bypassed.
