## What changed
- Simplified DB timezone resolution to resolve/cache the timezone ID inside the getter, defaulting to autodetect when config is empty and falling back to UTC if system lookup fails.
- Adjusted SQL Server timezone autodetect to match the current offset (including DST) against system zones and prefer canonical “Standard Time” IDs to avoid off-by-one-hour errors.
- Added inline guidance and a clean UTC fallback branch to `FwModel.convertUserInput` so every DateTime path remains reachable and normalized.
- ParsePage continues to assume UTC input while user-facing formatting happens via `FW.formatUserDateTime` and related helpers.

## Commands that worked (build/test/run)
- (none – dotnet CLI missing in container)

## Pitfalls - fixes
- `dotnet test` is unavailable because the container lacks the `dotnet` executable, so no automated build/test validation could run.

## Decisions - why
- Per-DB timezone resolution plus UTC normalization in `DB` keeps storage consistent while respecting connection-specific settings.
- Centralizing display conversion in `FW.formatUserDateTime` ensures UI paths use the user’s timezone regardless of which DB supplied the data.
- Moving user-input datetime conversion into `convertUserInput` keeps controllers thin while guaranteeing UTC normalization ahead of DB writes.
- ParsePage remains predictable by assuming UTC input and only handling output conversion for the user.

## Heuristics (keep terse)
- Run list/detail rows through `fw.formatUserDateTime` before returning JSON if ParsePage templating is bypassed.
