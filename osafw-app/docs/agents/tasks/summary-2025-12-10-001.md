## What changed
- Tracked DbDataReader and command in instance fields; disposal occurs via explicit `closeQuery()` calls or automatically when a new query starts (no wrapper pattern used).
- Ensured DB.exec commands use disposables (including MySQL command timeouts) to release resources deterministically.
- Tracked the active query command/reader and exposed `closeQuery` (with an optional reader argument) while keeping `disposeLastQuery` private to align manual callers with disposal order.
- Updated `AdminDBController` to release ad-hoc query readers through `db.closeQuery` so commands are disposed after callers finish reading, and routed DB disposal through the helper to avoid leaks.

## Commands that worked (build/test/run)
- `/root/dotnet/dotnet build /p:LibraryRestore=false`
- `/root/dotnet/dotnet test /p:LibraryRestore=false --no-build -v minimal` (fails: 79 tests, see Pitfalls)

## Pitfalls - fixes
- dotnet CLI is not on PATH; use `/root/dotnet/dotnet` directly.
- Queries invoked outside helper wrappers must close readers via `db.closeQuery` so the associated commands are disposed; starting a new `query` will dispose the previously tracked reader/command.
- `dotnet test` currently fails (79 failures) due to `NotImplementedException` in `UtilsTests.UploadFilesToRemoteUrlTest` and `name2humanTest` expecting a `NullReferenceException` that is not thrown.

## Decisions - why
- Added the reader wrapper to keep the existing query API while guaranteeing commands are disposed after use.
- Using `closeQuery` provides a single public entry point for cleanup while `disposeLastQuery` stays private to enforce disposal ordering.
- `exec` commands stay scoped in `using` blocks to match disposal expectations and avoid leaks.

## Heuristics (keep terse)
- For manually managed readers, call `closeQuery` to trigger command disposal.
- Run dotnet via its absolute path when the CLI is not on PATH.
